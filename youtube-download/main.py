"""
Script uses yt-dlp to create 720p videos with everything interesting embeded into filr.

It will try to download av1 codec for video with 720p resolution. If it is not available
it will download the best available codecs and resolution and it will scale and compress 
the video to 720p with h265 to save space. h265 provides fine quality with smaller size
(av1 is even better, but it takes ages to compress).

Thumbnails are also downloaded and converted to jpeg format to be more compatible. Subtitles 
are downloaded and embedded into the video file. Also metadata (as description, author, etc.)
is processed and embedded. 

Prerequisites:
apt update && apt install -y ffmpeg x265 && pip install yt-dlp ffmpeg-python Pillow langcodes pathvalidate
"""

import argparse
import tempfile
import os
import shutil
from pathlib import Path

import yt_dlp
import ffmpeg
import langcodes
import pathvalidate
from PIL import Image


parser = argparse.ArgumentParser(description='Download a video using yt_dlp.')
parser.add_argument('url', type=str, help='The URL of the video to download')

args = parser.parse_args()

def list_videos_in_playlist(url):
    ydl_opts = {
        #'flat_playlist': True,  # Extract video URLs without downloading them
    }

    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        info_dict = ydl.extract_info(url, download=False)

        # Check if the input is a playlist
        if 'entries' in info_dict:
            return info_dict['title'], [x['original_url'] for x in info_dict['entries']]
        else:
            return None, [url]

def download_video_and_process(pl_title, url):
    print(f'Downloading video from {pl_title}')
    temp = tempfile.mkdtemp(prefix='video-download-', dir='.')

    video_opts = {
        'writesubtitles': True,  # Download subtitles
        'subtitleslangs': ['en.*', 'sk', 'cs'],  # Preferred subtitle languages (English, Slovak, Czech)
        'writethumbnail': True,  # Download thumbnail
        'writeautomaticsub': False,  # Exclude autogenerated subtitles
        # if av1 codec is available for our target 720p, use it for video, 
        # otherwise use the best available codecs and we will scale and 
        # compress the video later in the script
        # it turns out we cannot really beat av1 with h265, we may convert
        # to av1 ourselves, but it is just painfully slow on current hardware
        'format': 'bestvideo[height=720][vcodec^=av01]+bestaudio/bestvideo*+bestaudio/best',
        # we want metadata, it is true, that everything we want here can 
        # be done with postprocessors, but there are some limitations
        # for example we cannot set the converted thumbnail quality
        # and we cannot set the language of the subtitles to show nicely
        'postprocessors': [{
            'key': 'FFmpegMetadata'
        }],
        'outtmpl': {
            'default': os.path.join(temp, 'video.%(title)s.%(id)s.%(ext)s'),
            'thumbnail': os.path.join(temp, 'thumbnail.%(title)s.%(id)s.%(ext)s'),
            'subtitle': os.path.join(temp, 'subtitle.%(title)s.%(id)s.%(ext)s'),
        } 
    }

    with yt_dlp.YoutubeDL(video_opts) as ydl:
        ydl.download(url)

    # now we should have video (with audio), thumbnail and subtitles downloaded
    # as separate files, we will merge them into a single file later

    title = id = ''

    paths = {
        'subtitles': {}
    }

    # walk through the temp directory and find all files
    with os.scandir(temp) as it:
        for entry in it:
            if entry.name.startswith('video'):
                # format is video.<title>.<id>.<ext>
                title = ''.join(entry.name.split('.')[1:-2])
                id = entry.name.split('.')[-2]
                paths['video'] = entry.path
            elif entry.name.startswith('thumbnail'):
                paths['thumbnail'] = entry.path
            elif entry.name.startswith('subtitle'):
                # cut the language code from the filename
                lang = entry.name.split('.')[-2]
                paths['subtitles'].update({
                    # convert language code to alpha3
                    # like 'en_US' -> 'eng'
                    langcodes.Language.get(lang).to_alpha3(): entry.path
                })

    # we will convert the cover to jpg, it is more compatible and
    # the loss in quality is not a big deal since we are using it as 
    # a thumbnail and it tend to be small on screen
    thumbnail = Image.open(paths['thumbnail'])
    # make path for the final thumbnail
    paths['thumbnail'] = os.path.join(temp, 'thumbnail.jpg')
    # seems resonable, yt uses webp and this has somehow similar size
    thumbnail.save(paths['thumbnail'], quality=70)

    # sanitize the filename, we will use it for the output file
    # replace ':' with ' - ' and merge multiple whitespaces into one
    sanitize = lambda x: pathvalidate.sanitize_filename(' '.join(x.replace(':', ' - ').split()))

    output_path = Path('.')                      # Use current directory
    output_path /= sanitize(pl_title) if pl_title else ''  # Append playlist title if available
    output_path.mkdir(parents=True, exist_ok=True)  # Create the directory if it does not exist
    output_path /= f'{sanitize(title)} - {id}.mp4'         # Append video title and id
    print(str(output_path))

    # use metadata for subtitles to show correct language
    sub_metadata = {
        f'metadata:s:s:{i}': f'language={v}' for i, v in enumerate(paths['subtitles'])
    }

    probe = ffmpeg.probe(paths['video'])
    video_stream = next((stream for stream in probe['streams'] if stream['codec_type'] == 'video'), None)
    recode = video_stream['codec_name'] != 'av1' or video_stream['height'] != 720

    video = ffmpeg.input(paths['video'])
    
    # we need to get the video and audio streams separately
    # https://github.com/kkroening/ffmpeg-python/issues/26
    # problem is that once we call filter it not longer maps
    # other streams (audio) to the output
    video_stream = video['v']
    audio_stream = video['a']
    if recode:
        # Apply the scale filter only to the first video stream
        video_stream = video_stream.filter('scale', w='min(1280,iw)', h='min(720,ih)', force_original_aspect_ratio='decrease', flags='lanczos+accurate_rnd')
    

    thumbnail = ffmpeg.input(paths['thumbnail'])['v']

    subtitles = [ffmpeg.input(x)['s'] for x in paths['subtitles'].values()]

    ffmpeg_output = os.path.join(temp, f'{id}.mp4')
    out = ffmpeg.output(video_stream, audio_stream, thumbnail, *subtitles,  # Input streams
            ffmpeg_output,                 # Output file
            acodec='copy',                    # Copy audio streams without re-encoding
            scodec='mov_text',                # Encode the subtitle stream as mov_text
            **{
                'c:v:0': 'libx265' if recode else 'copy',             # Encode the video stream as H.265
                'crf': 30,                    # Seems like good value for 720p
                'preset': 'slow',             # Sacrifice some speed for better compression
                'c:v:1': 'copy',                # Keep the thumbnail stream as it is
                'disposition:v:1': 'attached_pic', # Set the image stream as an attached picture (thumbnail)
                'movflags': 'faststart',      # Move the moov atom to the beginning of the file
                **sub_metadata,               # Set metadata for the subtitle stream
            }
        ).overwrite_output()                  # Allow overwriting the output file if it exists

    out.run()

    # Move the output file to the desired location
    shutil.move(ffmpeg_output, output_path)

    # If everything went well, we can remove the temp directory
    # It will be kept in case something goes wrong and we need to investigate
    shutil.rmtree(temp)

if __name__ == '__main__':
    pl_title, urls = list_videos_in_playlist(args.url)

    for url in urls:
        download_video_and_process(pl_title, url)


