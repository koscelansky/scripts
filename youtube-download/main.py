"""
Script uses yt-dlp and ffmpeg to create videos with everything interesting embeded into file.

It will try to download  best possible version of the video (including av1 codec) for given 
resolution. 

Thumbnails are also downloaded and converted to jpeg format to be more compatible. Subtitles 
are downloaded and embedded into the video file. Also metadata (as description, author, etc.)
is processed and embedded. 

Prerequisites:
apt update && apt install -y ffmpeg && pip install -r requirements.txt
"""

import argparse
import tempfile
import os
import shutil
from pathlib import Path

import yt_dlp
import ffmpeg
import langcodes
import pathvalidate
from PIL import Image


parser = argparse.ArgumentParser(description='Download a video using yt_dlp.')
parser.add_argument('url', type=str, help='The URL of the video to download')
parser.add_argument(
    "--quality",
    choices=["720p", "1080p", "4k", "hd", "fullhd"],
    default="720p",
    help="Set the video quality. Options: 720p, 1080p, 4k, fullhd, hd. Default is 720p. 'fullhd' and 'hd' is an alias for 1080p and 720p respectively."
)

args = parser.parse_args()

def get_format_string(max_res):
    """Generate yt-dlp format string to get the best quality up to a given resolution."""
    resolution_map = {
        "4k": "2160",
        "1080p": "1080",
        "fullhd": "1080",  # Alias for 1080p
        "720p": "720",
        "hd": "720",       # Alias for 720p
    }
    
    max_res_value = resolution_map.get(max_res, "720")  # Default to 720p if invalid

    # Prioritizing AV1 (codec=av01) but allowing other formats if unavailable
    # It may not be needed once AV1 is more widely available and yt-dlp stop 
    # deprioritizing it, videos are way smaller and quality is very good
    # Also prioritizing Opus (codec=opus) for audio
    format_str = f"(bestvideo[height<={max_res_value}][vcodec^=av01]/bestvideo[height<={max_res_value}])+(bestaudio[acodec^=opus]/bestaudio)/best[height<={max_res_value}]"

    return format_str

def list_videos_in_playlist(url):
    ydl_opts = {
        #'flat_playlist': True,  # Extract video URLs without downloading them
    }

    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        info_dict = ydl.extract_info(url, download=False)

        # Check if the input is a playlist
        if 'entries' in info_dict:
            return info_dict['title'], [x['original_url'] for x in info_dict['entries']]
        else:
            return None, [url]

def download_video_and_process(pl_title, url):
    print(f'Downloading video from {pl_title}')
    temp = tempfile.mkdtemp(prefix='video-download-', dir='.')

    video_opts = {
        'writesubtitles': True,  # Download subtitles
        'subtitleslangs': ['en.*', 'sk', 'cs'],  # Preferred subtitle languages (English, Slovak, Czech)
        'writethumbnail': True,  # Download thumbnail
        'writeautomaticsub': False,  # Exclude autogenerated subtitles
        'format': get_format_string(args.quality),
        # we want metadata, it is true, that everything we want here can 
        # be done with postprocessors, but there are some limitations
        # for example we cannot set the converted thumbnail quality
        # and we cannot set the language of the subtitles to show nicely
        'postprocessors': [{
            'key': 'FFmpegMetadata'
        }],
        'outtmpl': {
            'default': os.path.join(temp, 'video.%(title)s.%(id)s.%(ext)s'),
            'thumbnail': os.path.join(temp, 'thumbnail.%(title)s.%(id)s.%(ext)s'),
            'subtitle': os.path.join(temp, 'subtitle.%(title)s.%(id)s.%(ext)s'),
        } 
    }

    with yt_dlp.YoutubeDL(video_opts) as ydl:
        ydl.download(url)

    # now we should have video (with audio), thumbnail and subtitles downloaded
    # as separate files, we will merge them into a single file later

    title = id = ''

    paths = {
        'subtitles': {}
    }

    # walk through the temp directory and find all files
    with os.scandir(temp) as it:
        for entry in it:
            if entry.name.startswith('video'):
                # format is video.<title>.<id>.<ext>
                title = ''.join(entry.name.split('.')[1:-2])
                id = entry.name.split('.')[-2]
                paths['video'] = entry.path
            elif entry.name.startswith('thumbnail'):
                paths['thumbnail'] = entry.path
            elif entry.name.startswith('subtitle'):
                # cut the language code from the filename
                lang = entry.name.split('.')[-2]
                paths['subtitles'].update({
                    # convert language code to alpha3
                    # like 'en_US' -> 'eng'
                    langcodes.Language.get(lang).to_alpha3(): entry.path
                })

    # we will convert the cover to jpg, it is more compatible and
    # the loss in quality is not a big deal since we are using it as 
    # a thumbnail and it tend to be small on screen
    thumbnail = Image.open(paths['thumbnail'])
    # make path for the final thumbnail
    paths['thumbnail'] = os.path.join(temp, 'thumbnail.jpg')
    # seems resonable, yt uses webp and this has somehow similar size
    thumbnail.save(paths['thumbnail'], quality=70)

    # sanitize the filename, we will use it for the output file
    # replace ':' with ' - ' and merge multiple whitespaces into one
    sanitize = lambda x: pathvalidate.sanitize_filename(' '.join(x.replace(':', ' - ').split()))

    output_path = Path('.')                      # Use current directory
    output_path /= sanitize(pl_title) if pl_title else ''  # Append playlist title if available
    output_path.mkdir(parents=True, exist_ok=True)  # Create the directory if it does not exist
    output_path /= f'{sanitize(title)} - {id}.mp4'         # Append video title and id
    print(str(output_path))

    # use metadata for subtitles to show correct language
    sub_metadata = {
        f'metadata:s:s:{i}': f'language={v}' for i, v in enumerate(paths['subtitles'])
    }

    video = ffmpeg.input(paths['video']) # This is either just video or video with audio
    thumbnail = ffmpeg.input(paths['thumbnail'])['v']
    subtitles = [ffmpeg.input(x)['s'] for x in paths['subtitles'].values()]

    ffmpeg_output = os.path.join(temp, f'{id}.mp4')
    out = ffmpeg.output(video, thumbnail, *subtitles,  # Input streams
            ffmpeg_output,                  # Output file
            acodec='copy',                  # Copy audio streams without re-encoding
            vcodec='copy',                  # Copy video streams without re-encoding
            scodec='mov_text',              # Encode the subtitle stream as mov_text
            **{
                'disposition:v:1': 'attached_pic', # Set the image stream as an attached picture (thumbnail)
                'movflags': 'faststart',    # Move the moov atom to the beginning of the file
                **sub_metadata,             # Set metadata for the subtitle stream
            }
        ).overwrite_output()                # Allow overwriting the output file if it exists

    out.run()

    # Move the output file to the desired location
    shutil.move(ffmpeg_output, output_path)

    # If everything went well, we can remove the temp directory
    # It will be kept in case something goes wrong and we need to investigate
    shutil.rmtree(temp)

if __name__ == '__main__':
    pl_title, urls = list_videos_in_playlist(args.url)

    for url in urls:
        download_video_and_process(pl_title, url)
